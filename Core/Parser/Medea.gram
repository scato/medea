grammar Medea
{
    options
    {
        Axiom = "Script";
        Separator = "SEPARATOR";
        OutputPath = "Core\\Parser";
        Namespace = "Medea.Core.Parser";
        AccessModifier = "Public";
    }

    terminals
    {
        WHITE_SPACE -> U+0020 | U+0009 | U+000B | U+000C;
        SEPARATOR   -> WHITE_SPACE+;

        NUMBER -> '-'? ('0' | [1-9] [0-9]*) ('.' [0-9]*)? ([Ee] [+-] [0-9]*)?;

        STRING -> '"' ([^"\\\n\r] | ('\\' .))* '"'
                | '\'' ([^'\\\n\r] | ('\\' .))* '\'';

        IDENTIFIER -> (uc{L} | uc{Nl} | '$' | '_') (uc{L} | uc{Nl} | uc{Mn} | uc{Mc} | uc{Nd} | uc{Pc} | '$')*;
    }

    rules
    {
        Script -> Statement ';';

        // see https://s3.amazonaws.com/artifacts.opencypher.org/M18/railroad/Cypher.html#Query
        Statement -> Query^;

        Query -> ReadingClause+ UpdatingClause?;
        Query -> UpdatingClause;

        ReadingClause -> Load^;

        Load -> ~'LOAD'! (~'RAW') ~'FROM'! Pattern ~'AS'! Pattern;

        UpdatingClause -> Return^;

        Return -> ~'RETURN'! Expression;

        // see https://tc39.es/ecma262/#sec-destructuring-assignment
        Pattern -> PrimaryPattern^;

        PrimaryPattern -> IdentifierReference^;
        PrimaryPattern -> Literal^;

        // see https://tc39.es/ecma262/#prod-Expression
        Expression -> PrimaryExpression^;

        PrimaryExpression -> IdentifierReference^;
        PrimaryExpression -> Literal^;

        IdentifierReference -> IDENTIFIER;

        Literal -> NumericLiteral^;
        Literal -> StringLiteral^;

        NumericLiteral -> NUMBER;
        StringLiteral -> STRING;
    }
}
